#!/usr/bin/python3
"""
Script to perform different tests against a OAUTH 2.x Authorization Server or OpenID Provider
in order to identity interesting elements that can be part of its attack surface.

Each function named "test_*" is dedicated to a test.

Tests are based on the following research:
    https://github.com/ExcelliumSA/OAuth2OIDC-Study

The tests list is here:
    https://github.com/ExcelliumSA/OAuth2OIDC-Study/blob/main/OAauth2_OIDC_Security_Validations.md

Dependencies:
    pip3 install requests termcolor colorama tabulate

Sources used:
    https://connect2id.com/learn
    https://auth0.com/docs/flows
    https://www.keycloak.org/docs-api/9.0/javadocs/constant-values.html
    https://github.com/keycloak/keycloak-documentation/blob/master/securing_apps/topics/oidc/javascript-adapter.adoc

Script was tested against the following OAUTH/OIDC systems:
    KEYCLOAK: https://www.keycloak.org/getting-started/getting-started-docker

"""
import requests
import re
import argparse
import colorama
from termcolor import colored
from tabulate import tabulate
from urllib.parse import urlparse

# Config
# Disable TLS warning when validation is disabled when requests is used
requests.packages.urllib3.disable_warnings(requests.packages.urllib3.exceptions.InsecureRequestWarning)

# Constants
PROXIES = {}
COMMON_SCOPES = ["address", "email", "openid", "phone", "profile", "offline_access", "microprofile-jwt", "role_list", "roles", "web-origins"]
COMMON_CLIENTID = ["account", "account-console", "admin-cli", "broker", "realm-management", "security-admin-console"]
COMMON_REALMS = ["master"]
OIDC_METADATA_ENDPOINT_RELATIVE_PATH = ".well-known/openid-configuration"


def render_results(data, column_headers=["Key", "Value"]):
    """
    Print result depending on data structure.
    """
    if isinstance(data, list):
        print(", ".join(data))
    elif isinstance(data, dict):
        table_rows = []
        for key, value in data.items():
            if isinstance(value, list):
                table_rows.append([key, ", ".join(value)])
            else:
                table_rows.append([key, value])
        print(tabulate(table_rows, headers=column_headers, tablefmt="github"))
    elif data is not None:
        print(data)


def get_requests_session():
    """
    Preconfigure a 'Requests' session to speed-up HTTP interactions.
    """
    session = requests.Session()
    session.verify = False
    session.proxies.update(PROXIES)
    session.headers.update({"User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:89.0) Gecko/20100101 Firefox/89.0"})
    return session


def get_page_type(http_response):
    """
    Determine the type of response depending on the OAUTH/OIDC systems specificities.
    """
    page_type = "NA"
    # KEYCLOAK
    if http_response.status_code == 200 and "sign in" in http_response.text.lower():
        page_type = "LOGIN"
    elif http_response.status_code in [301, 302] and "error_description=" in http_response.headers["Location"].lower():
        page_type = "ERROR"
    elif http_response.status_code == 403:
        page_type = "ACCESS_DENIED"
    elif http_response.status_code == 400 and "invalid parameter: redirect_uri" in http_response.text.lower():
        page_type = "INVALID_REDIRECT_URI"
    # GENERIC
    elif http_response.status_code == 200 and http_response.headers["Content-Type"] == "application/json" and "grant_types_supported" in http_response.json():
        page_type = "OPENID_CONFIGURATION"
    return page_type


def get_system_software(base_url):
    """
    Try ty identify the software operating the OAUTH/OIDC systems depending on the OAUTH/OIDC softwares specificities.
    """
    url_components = urlparse(base_url)
    software_name = "NA"
    # KEYCLOAK: Check the presence of the JS library
    with get_requests_session() as session:
        resp = session.get(url=f"{url_components.scheme}://{url_components.netloc}/auth/js/keycloak.js", allow_redirects=False)
        if resp.status_code == 200 and "text/javascript" in resp.headers["Content-Type"]:
            software_name = "Keycloak"
    return software_name


def get_protected_app_back_link(http_response):
    """
    Extract the URL of the protected application depending on the OAUTH/OIDC systems specificities.
    """
    back_link = "NA"
    # KEYCLOAK
    if http_response.status_code == 400 and "backToApplication" in http_response.text:
        # Example: <a id="backToApplication" href="http://localhost:9500/App.html">Back to Application</a>
        back_link = re.findall(r'<a\sid="backToApplication"\shref="(.*)"\s?>', http_response.text)[0]
    return back_link


def get_realms_base_url(base_url):
    """
    Determine the base url for REALMS depending on the OAUTH/OIDC systems specificities.
    """
    base_url_realms = base_url
    # KEYCLOAK
    marker = "/realms/"
    if marker in base_url_realms:
        base_url_realms = base_url_realms[0:base_url_realms.index(marker) + (len(marker)-1)]
    return base_url_realms


def disable_existing_parameters(base_url, parameter_list_to_disable=["client_id", "response_type", "code_challenge", "code_challenge_method", "scope"]):
    """
    Disable any existing parameter present in the base url present into the provided list. Prevent collisions with parameters added by test functions.
    """
    for param_name in parameter_list_to_disable:
        base_url = base_url.replace(f"{param_name}=", f"xxx_{param_name}=")
    return base_url


def test_enabled_flows(base_url):
    """
    Identify all enabled OAUTH flows that can be initialized without having Client Credentials.
    """
    # Prevent parameter collisions
    work_url = disable_existing_parameters(base_url, ["response_type", "code_challenge", "code_challenge_method"])
    results = {}
    # Define the url parameters for each type of flow
    flows = {}
    flows["IMPLICIT"] = "response_type=token"
    flows["AUTHORIZATION_CODE"] = "response_type=code"
    flows["AUTHORIZATION_CODE_WITH_PKCE_WITH_S256_CHALLENGE_HASH"] = "response_type=code&code_challenge=-sUEoAV-txYvhniiuJ4-gwNCtsiD2XiIPvLQYm-sUsE&code_challenge_method=S256"
    flows["AUTHORIZATION_CODE_WITH_PKCE_WITH_PLAIN_CHALLENGE"] = f"response_type=code&code_challenge={'x'*43}&code_challenge_method=plain"
    # Test flows enabling state
    with get_requests_session() as session:
        for flow in flows:
            session.cookies.clear()
            resp = session.get(url=f"{work_url}&{flows[flow]}", allow_redirects=False)
            # If flow is disabled then an HTTP 30x is received with error in the redirection url.
            # Otherwise it should return a login page because we do not provide any existing session cookie
            results[flow] = (get_page_type(resp) == "LOGIN")
    return results


def test_allowed_scopes(base_url, scope_list_source):
    """
    Identify all allowed scopes for the current client ID.
    """
    # Prevent parameter collisions
    work_url = disable_existing_parameters(base_url, ["response_type", "scope", "code_challenge", "code_challenge_method"])
    results = []
    # Add common scopes to the provided list
    scopes = list(set(scope_list_source + COMMON_SCOPES))
    # Use the Authorization Code flow because it is commonly enabled
    with get_requests_session() as session:
        for scope in scopes:
            print(f"\rTesting scope: {scope:<50}", end="", flush=True)
            session.cookies.clear()
            resp = session.get(url=f"{work_url}&response_type=code&scope={scope}", allow_redirects=False)
            # If scope is not allowed then an HTTP 30x is received with error in the redirection url.
            # Otherwise it should return a login page because we do not provide any existing session cookie.
            if get_page_type(resp) == "LOGIN":
                results.append(scope)
    print(f"\r{' '*50}", end="", flush=True)
    print("\r", end="", flush=True)
    results.sort()
    return results


def test_existing_clients(base_url, clientid_list_source):
    """
    Identify all configured clients based on their client ID.
    """
    # Prevent parameter collisions
    work_url = disable_existing_parameters(base_url, ["client_id", "response_type", "redirect_uri", "scope", "code_challenge", "code_challenge_method"])
    results = []
    # Add common client id to the provided list
    client_ids = list(set(clientid_list_source + COMMON_CLIENTID))
    # Use the Authorization Code flow because it is commonly enabled
    with get_requests_session() as session:
        for client_id in client_ids:
            print(f"\rTesting ID: {client_id:<50}", end="", flush=True)
            session.cookies.clear()
            resp = session.get(url=f"{work_url}&client_id={client_id}&response_type=code&scope=openid&redirect_uri=http://explicit-invalid.com", allow_redirects=False)
            # If the client do not exist then an HTTP 400 is returned with the text "Client not found".
            # If the client exist then an HTTP 400 is returned with the text "Invalid parameter: redirect_uri" because the redirect_uri specified is explictly invalid for the client ID.
            # We accept an HTTP 200 if it is the login page.
            # We accept an HTTP 403 because it indicate that the CLient is defined but access is denied.
            if get_page_type(resp) in ["LOGIN", "INVALID_REDIRECT_URI", "ACCESS_DENIED"]:
                results.append(client_id)
    print(f"\r{' '*50}", end="", flush=True)
    print("\r", end="", flush=True)
    results.sort()
    return results


def test_allowed_localhost_redirection(base_url):
    """
    Identify if a localhost redirection is allowed for the current client ID.
    """
    # Prevent parameter collisions
    work_url = disable_existing_parameters(base_url, ["response_type", "redirect_uri", "scope", "code_challenge", "code_challenge_method"])
    results = []
    # Use the Authorization Code flow because it is commonly enabled
    with get_requests_session() as session:
        for port in range(1, 65536):
            for protocol in ["http", "https"]:
                for host in ["localhost", "127.0.0.1"]:
                    redirection_url = f"{protocol}://{host}:{port}"
                    print(f"\rTesting redirection url: {redirection_url:<50}", end="", flush=True)
                    session.cookies.clear()
                    resp = session.get(url=f"{work_url}&response_type=code&scope=openid&redirect_uri={redirection_url}", allow_redirects=False)
                    # If the redirection is accepted then the login page should be presented with an HTTP 200 because we do not provide any existing session cookie.
                    if get_page_type(resp) == "LOGIN":
                        results.append(redirection_url)
    print(f"\r{' '*50}", end="", flush=True)
    print("\r", end="", flush=True)
    results.sort()
    return results


def test_map_client_to_protected_app(base_url, clientid_list_source):
    """
    Identify the protected application associated to each client of the provided list by abusing the "redirect_uri" parameter and its associated error page.
    """
    # Prevent parameter collisions
    work_url = disable_existing_parameters(base_url, ["client_id", "response_type", "redirect_uri", "scope", "code_challenge", "code_challenge_method"])
    results = {}
    client_ids = clientid_list_source
    # Use the Authorization Code flow because it is commonly enabled
    with get_requests_session() as session:
        for client_id in client_ids:
            session.cookies.clear()
            resp = session.get(url=f"{work_url}&client_id={client_id}&response_type=code&scope=openid&redirect_uri=http://explicit-invalid.com", allow_redirects=False)
            results[client_id] = get_protected_app_back_link(resp)
    return results


def test_existing_realms(base_url, realms_list_source):
    """
    Identify all configured realms via their associated metadata endpoint.
    """
    # Add common realms to the provided list
    realms = list(set(realms_list_source + COMMON_REALMS))
    # Get base url for realms
    base_url_realms = get_realms_base_url(base_url)
    # Try to enumerate realms
    results = {}
    with get_requests_session() as session:
        for realm in realms:
            session.cookies.clear()
            print(f"\rTesting value: {realm:<50}", end="", flush=True)
            metadata_edp_url = f"{base_url_realms}/{realm}/{OIDC_METADATA_ENDPOINT_RELATIVE_PATH}"
            resp = session.get(url=metadata_edp_url, allow_redirects=True)
            if get_page_type(resp) == "OPENID_CONFIGURATION":
                results[realm] = metadata_edp_url
    print(f"\r{' '*50}", end="", flush=True)
    print("\r", end="", flush=True)
    return results


def test_none_signing_algorithm_support(metadata_json_url):
    """
    Find, in the OpenID configuration settings, ones for which the support of the NONE signature algorithm is enabled.
    """
    results = []
    targeted_setting_keys = ["id_token_signing_alg_values_supported", "userinfo_signing_alg_values_supported", "request_object_signing_alg_values_supported",
                             "token_endpoint_auth_signing_alg_values_supported", "introspection_endpoint_auth_signing_alg_values_supported", "revocation_endpoint_auth_signing_alg_values_supported"]
    with get_requests_session() as session:
        json_data = session.get(url=metadata_json_url, allow_redirects=True).json()
    for setting_key in targeted_setting_keys:
        for algorithm in json_data[setting_key]:
            if algorithm.lower() == "none":
                results.append(setting_key)
                break
    results.sort()
    return results


if __name__ == "__main__":
    colorama.init()
    title_color = "yellow"
    info_color = "cyan"
    parser = argparse.ArgumentParser()
    required_params = parser.add_argument_group("required arguments")
    required_params.add_argument("--client-id", action="store", dest="client_id", help="Identifier of the target Client.", required=True)
    required_params.add_argument("--valid-redirect-uri", action="store", dest="valid_redirect_uri", help="Valid redirection uri for the target Client.", required=True)
    required_params.add_argument("--sts-endpoint", action="store", dest="sts_base_url", help="OAUTH/OIDC endpoint to use (ex: http://localhost:8080/auth/realms/demo/protocol/openid-connect/auth).", required=True)
    parser.add_argument("--proxy", action="store", dest="http_proxy", default=None, help="HTTP proxy to use for all HTTP call to differents services (ex: http://88.198.50.103:9080). Default to None", required=False)
    parser.add_argument("--words-file", action="store", dest="words_dictionary", default="/tools/sec-lists/Discovery/Web-Content/raft-small-words.txt", help="Path to a text file containing words used for all enumeration operations. Default to the file 'raft-small-words.txt' from the local SecLists GitHub repo clone.", required=False)
    parser.add_argument("--list-local-redirect", action="store_true", dest="list_local_redirect", default=False, help="List allowed localhost redirection on the STS for the specified Client ID. Default to False", required=False)
    args = parser.parse_args()
    words_file = args.words_dictionary
    if args.http_proxy is not None:
        PROXIES["http"] = args.http_proxy
        PROXIES["https"] = args.http_proxy
    else:
        PROXIES.clear()
    print(colored("[i]", info_color, attrs=["bold"]) + " STS refer to the target 'OAuth Authorization Server' or 'OpenID Provider' instance.")
    print(colored(f"[+] Compose the base url based on parameters provided:", title_color, attrs=["bold"]))
    work_url = args.sts_base_url.split("?")[0]
    client_id = args.client_id
    redirect_uri = args.valid_redirect_uri
    base_url = f"{work_url}?client_id={client_id}&redirect_uri={redirect_uri}"
    print(base_url)
    print(colored(f"[+] Identify the software operating the STS...", title_color, attrs=["bold"]))
    results = get_system_software(base_url)
    print(results)
    print(colored(f"[+] Load the list of words from file '{words_file}'...", title_color, attrs=["bold"]))
    with open(words_file, "r") as f:
        words = f.read().splitlines()
    words.append(client_id)
    words.append(client_id.lower())
    words.append(client_id.upper())
    words.append(client_id.capitalize())
    print(f"{len(words)} words loaded in memory.")
    print(colored(f"[+] List enabled flows on the STS for the specified Client ID...", title_color, attrs=["bold"]))
    results = test_enabled_flows(base_url)
    render_results(results, column_headers=["Flow", "Enabled"])
    print(colored(f"[+] Enumerate allowed Scopes on the STS for the specified Client ID...", title_color, attrs=["bold"]))
    results = test_allowed_scopes(base_url, words)
    render_results(results)
    print(colored(f"[+] Enumerate defined Clients on the STS...", title_color, attrs=["bold"]))
    client_id_list = test_existing_clients(base_url, words)
    render_results(client_id_list)
    print(colored(f"[+] Enumerate protected apps by the STS...", title_color, attrs=["bold"]))
    results = test_map_client_to_protected_app(base_url, client_id_list)
    render_results(results, column_headers=["Client ID", "App URL"])
    print(colored(f"[+] Enumerate defined Realms on the STS...", title_color, attrs=["bold"]))
    realms = test_existing_realms(base_url, words)
    render_results(realms, column_headers=["Realm ID", "Metadata endpoint URL"])
    print(colored(f"[+] Enumerate defined Realms on the STS for which the NONE signature algorithm is supported...", title_color, attrs=["bold"]))
    results = {}
    for realm_name, realm_metadata_endpoint in realms.items():
        settings = test_none_signing_algorithm_support(realm_metadata_endpoint)
        if len(settings) > 0:
            results[realm_name] = settings
    render_results(results, column_headers=["Realm ID", "Setting keys"])
    if args.list_local_redirect:
        print(colored(f"[+] List allowed localhost redirection on the STS for the specified Client ID...", title_color, attrs=["bold"]))
        results = test_allowed_localhost_redirection(base_url)
        render_results(results)
