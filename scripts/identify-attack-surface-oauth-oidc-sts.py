#!/usr/bin/python3
"""
Script to perform different tests against a OAUTH 2.x Authorization Server or OpenID Provider
in order to identity interesting elements that can be part of its attack surface.

Each function named "test_*" is dedicated to a test.

The approach decided was to not mandary count on the information from the "/.well-known/openid-configuration" file and been able
to spot elements even if the descriptor file is not reacheable.

Tests are based on the following research:
    https://github.com/ExcelliumSA/OAuth2OIDC-Study

The tests list is here:
    https://github.com/ExcelliumSA/OAuth2OIDC-Study/blob/main/OAauth2_OIDC_Security_Validations.md

Dependencies:
    pip3 install requests termcolor colorama tabulate pyJWT pycryptodome

Sources used:
    https://connect2id.com/learn
    https://auth0.com/docs/flows
    https://auth0.com/docs/protocols/protocol-oauth2
    https://www.keycloak.org/docs-api/9.0/javadocs/constant-values.html
    https://github.com/keycloak/keycloak-documentation/blob/master/securing_apps/topics/oidc/javascript-adapter.adoc
    https://datatracker.ietf.org/doc/html/rfc7636#section-4.1
    https://datatracker.ietf.org/doc/html/rfc7636#section-4.2
    https://openid.net/specs/openid-connect-core-1_0.html#rfc.section.6.2

Script was tested against the following OAUTH/OIDC systems:
    KEYCLOAK: https://www.keycloak.org/getting-started/getting-started-docker

"""
import requests
import re
import argparse
import colorama
import jwt
import uuid
import statistics
from termcolor import colored
from tabulate import tabulate
from urllib.parse import urlparse
from cryptography.hazmat.primitives import serialization

# Config
# Disable TLS warning when validation is disabled when requests is used
requests.packages.urllib3.disable_warnings(requests.packages.urllib3.exceptions.InsecureRequestWarning)

# Constants
PROXIES = {}
TLS_CLIENT_CERT = None
COMMON_SCOPES = ["address", "email", "openid", "phone", "profile", "offline_access", "microprofile-jwt", "role_list", "roles", "web-origins", "aisp", "pisp", "extended_transaction_history"]
COMMON_CLIENTID = ["account", "account-console", "admin-cli", "broker", "realm-management", "security-admin-console"]
COMMON_REALMS = ["master"]
OIDC_METADATA_ENDPOINT_RELATIVE_PATH = ".well-known/openid-configuration"
COMMON_RESPONSE_MODES = ["query", "fragment", "form_post", "web_message"]


def render_results(data, column_headers=["Key", "Value"]):
    """
    Print result depending on data structure.
    """
    if isinstance(data, list) and len(data) > 0:
        print(", ".join(data))
    elif isinstance(data, dict) and len(data) > 0:
        table_rows = []
        for key, value in data.items():
            if isinstance(value, list):
                table_rows.append([key, ", ".join(value)])
            else:
                table_rows.append([key, value])
        print(tabulate(table_rows, headers=column_headers, tablefmt="github"))
    elif (isinstance(data, list) or isinstance(data, dict)) and len(data) == 0:
        print("No data found.")
    elif data is not None:
        print(data)


def get_requests_session():
    """
    Preconfigure a 'Requests' session to speed-up HTTP interactions.
    """
    session = requests.Session()
    session.verify = False
    session.proxies.update(PROXIES)
    session.cert = TLS_CLIENT_CERT
    session.headers.update({"User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:89.0) Gecko/20100101 Firefox/89.0"})
    return session


def get_page_type(http_response):
    """
    Determine the type of response depending on the OAUTH/OIDC systems specificities and case meet during assessments.
    """
    page_type = "NA"
    # KEYCLOAK
    if http_response.status_code == 200 and ("sign in" in http_response.text.lower() or "log in" in http_response.text.lower()):
        page_type = "LOGIN"
    elif http_response.status_code in [301, 302] and "error_description=" in http_response.headers["Location"].lower():
        page_type = "ERROR"
    elif http_response.status_code == 403:
        page_type = "ACCESS_DENIED"
    elif http_response.status_code in [200, 400] and "invalid parameter: redirect_uri" in http_response.text.lower():
        page_type = "INVALID_REDIRECT_URI"
    elif http_response.status_code in [200, 400] and ("invalid request" in http_response.text.lower() or "invalid_request" in http_response.text.lower()):
        page_type = "SERVER_SIDE_ERROR"
    # GENERIC
    elif http_response.status_code == 200 and http_response.headers["Content-Type"] == "application/json" and "grant_types_supported" in http_response.json():
        page_type = "OPENID_CONFIGURATION"
    # SPECIFIC
    elif http_response.status_code == 200 and "luxtrust" in http_response.text.lower():
        page_type = "LOGIN"
    return page_type


def get_system_software(base_url):
    """
    Try ty identify the software operating the OAUTH/OIDC systems depending on the OAUTH/OIDC softwares specificities.
    """
    url_components = urlparse(base_url)
    software_name = "NA"
    # KEYCLOAK: Check the presence of the JS library
    with get_requests_session() as session:
        resp = session.get(url=f"{url_components.scheme}://{url_components.netloc}/auth/js/keycloak.js", allow_redirects=False)
        if resp.status_code == 200 and "text/javascript" in resp.headers["Content-Type"]:
            software_name = "Keycloak"
    return software_name


def get_protected_app_back_link(http_response):
    """
    Extract the URL of the protected application depending on the OAUTH/OIDC systems specificities.
    """
    back_link = "NA"
    # KEYCLOAK
    if http_response.status_code == 400 and "backToApplication" in http_response.text:
        # Example: <a id="backToApplication" href="http://localhost:9500/App.html">Back to Application</a>
        back_link = re.findall(r'<a\sid="backToApplication"\shref="(.*)"\s?>', http_response.text)[0]
    return back_link


def get_realms_base_url(base_url):
    """
    Determine the base url for REALMS depending on the OAUTH/OIDC systems specificities.
    """
    base_url_realms = base_url
    # KEYCLOAK
    marker = "/realms/"
    if marker in base_url_realms:
        base_url_realms = base_url_realms[0:base_url_realms.index(marker) + (len(marker)-1)]
    return base_url_realms


def disable_existing_parameters(base_url, parameter_list_to_disable=["client_id", "response_type", "code_challenge", "code_challenge_method", "scope"]):
    """
    Disable any existing parameter present in the base url present into the provided list. Prevent collisions with parameters added by test functions.
    """
    for param_name in parameter_list_to_disable:
        base_url = base_url.replace(f"{param_name}=", f"xxx_{param_name}=")
    return base_url


def test_enabled_flows(base_url):
    """
    Identify all enabled OAUTH flows that can be initialized without having Client Credentials.
    """
    # Prevent parameter collisions
    work_url = disable_existing_parameters(base_url, ["response_type", "code_challenge", "code_challenge_method"])
    results = {}
    # Define the url parameters for each type of flow
    flows = {}
    flows["IMPLICIT"] = "response_type=token"
    flows["AUTHORIZATION_CODE"] = "response_type=code"
    flows["AUTHORIZATION_CODE_WITH_PKCE_WITH_S256_CHALLENGE_HASH"] = "response_type=code&code_challenge=-sUEoAV-txYvhniiuJ4-gwNCtsiD2XiIPvLQYm-sUsE&code_challenge_method=S256"
    flows["AUTHORIZATION_CODE_WITH_PKCE_WITH_PLAIN_CHALLENGE"] = f"response_type=code&code_challenge={'x'*43}&code_challenge_method=plain"
    # Test flows enabling state
    with get_requests_session() as session:
        for flow in flows:
            session.cookies.clear()
            resp = session.get(url=f"{work_url}&{flows[flow]}", allow_redirects=True)
            # If flow is disabled then an HTTP 30x is received with error in the redirection url.
            # Otherwise it should return a login page because we do not provide any existing session cookie
            results[flow] = (get_page_type(resp) == "LOGIN")
    return results


def test_allowed_scopes(base_url, scope_list_source):
    """
    Identify all allowed scopes for the current client ID.
    """
    # Prevent parameter collisions
    work_url = disable_existing_parameters(base_url, ["response_type", "scope", "code_challenge", "code_challenge_method"])
    results = []
    # Add common scopes to the provided list
    scopes = list(set(scope_list_source + COMMON_SCOPES))
    # Use the Authorization Code flow because it is commonly enabled
    with get_requests_session() as session:
        for scope in scopes:
            print(f"\rTesting scope: {scope:<50}", end="", flush=True)
            session.cookies.clear()
            resp = session.get(url=f"{work_url}&response_type=code&scope={scope}", allow_redirects=True)
            # If scope is not allowed then an HTTP 30x is received with error in the redirection url.
            # Otherwise it should return a login page because we do not provide any existing session cookie.
            if get_page_type(resp) == "LOGIN":
                results.append(scope)
    print(f"\r{' '*50}", end="", flush=True)
    print("\r", end="", flush=True)
    results.sort()
    return results


def test_existing_clients(base_url, clientid_list_source):
    """
    Identify all configured clients based on their client ID.
    """
    # Prevent parameter collisions
    work_url = disable_existing_parameters(base_url, ["client_id", "response_type", "redirect_uri", "scope", "code_challenge", "code_challenge_method"])
    results = []
    # Add common client id to the provided list
    client_ids = list(set(clientid_list_source + COMMON_CLIENTID))
    # Use the Authorization Code flow because it is commonly enabled
    with get_requests_session() as session:
        for client_id in client_ids:
            print(f"\rTesting ID: {client_id:<50}", end="", flush=True)
            session.cookies.clear()
            resp = session.get(url=f"{work_url}&client_id={client_id}&response_type=code&scope=openid&redirect_uri=http://explicit-invalid.com", allow_redirects=True)
            # If the client do not exist then an HTTP 400 is returned with the text "Client not found".
            # If the client exist then an HTTP 400 is returned with the text "Invalid parameter: redirect_uri" because the redirect_uri specified is explictly invalid for the client ID.
            # We accept an HTTP 200 if it is the login page.
            # We accept an HTTP 403 because it indicate that the CLient is defined but access is denied.
            if get_page_type(resp) in ["LOGIN", "INVALID_REDIRECT_URI", "ACCESS_DENIED"]:
                results.append(client_id)
    print(f"\r{' '*50}", end="", flush=True)
    print("\r", end="", flush=True)
    results.sort()
    return results


def test_allowed_localhost_redirection(base_url):
    """
    Identify if a localhost redirection is allowed for the current client ID.
    """
    # Prevent parameter collisions
    work_url = disable_existing_parameters(base_url, ["response_type", "redirect_uri", "scope", "code_challenge", "code_challenge_method"])
    results = []
    # Use the Authorization Code flow because it is commonly enabled
    with get_requests_session() as session:
        for port in range(1, 65536):
            for protocol in ["http", "https"]:
                for host in ["localhost", "127.0.0.1"]:
                    redirection_url = f"{protocol}://{host}:{port}"
                    print(f"\rTesting redirection url: {redirection_url:<50}", end="", flush=True)
                    session.cookies.clear()
                    resp = session.get(url=f"{work_url}&response_type=code&scope=openid&redirect_uri={redirection_url}", allow_redirects=True)
                    # If the redirection is accepted then the login page should be presented with an HTTP 200 because we do not provide any existing session cookie.
                    if get_page_type(resp) == "LOGIN":
                        results.append(redirection_url)
    print(f"\r{' '*50}", end="", flush=True)
    print("\r", end="", flush=True)
    results.sort()
    return results


def test_map_client_to_protected_app(base_url, clientid_list_source):
    """
    Identify the protected application associated to each client of the provided list by abusing the "redirect_uri" parameter and its associated error page.
    """
    # Prevent parameter collisions
    work_url = disable_existing_parameters(base_url, ["client_id", "response_type", "redirect_uri", "scope", "code_challenge", "code_challenge_method"])
    results = {}
    client_ids = clientid_list_source
    # Use the Authorization Code flow because it is commonly enabled
    with get_requests_session() as session:
        for client_id in client_ids:
            session.cookies.clear()
            resp = session.get(url=f"{work_url}&client_id={client_id}&response_type=code&scope=openid&redirect_uri=http://explicit-invalid.com", allow_redirects=True)
            results[client_id] = get_protected_app_back_link(resp)
    return results


def test_existing_realms(base_url, realms_list_source):
    """
    Identify all configured realms via their associated metadata endpoint.
    """
    # Add common realms to the provided list
    realms = list(set(realms_list_source + COMMON_REALMS))
    # Get base url for realms
    base_url_realms = get_realms_base_url(base_url)
    # Try to enumerate realms
    results = {}
    with get_requests_session() as session:
        for realm in realms:
            session.cookies.clear()
            print(f"\rTesting value: {realm:<50}", end="", flush=True)
            metadata_edp_url = f"{base_url_realms}/{realm}/{OIDC_METADATA_ENDPOINT_RELATIVE_PATH}"
            # I meet case in which some realms are protected by dedicated client cert so I handle error cases
            try:
                resp = session.get(url=metadata_edp_url, allow_redirects=True)
            except:
                continue
            if get_page_type(resp) == "OPENID_CONFIGURATION":
                results[realm] = metadata_edp_url
    print(f"\r{' '*50}", end="", flush=True)
    print("\r", end="", flush=True)
    return results


def test_realms_client_self_registration_endpoint(realms_collection_infos):
    """
    Identify the client self-registration endpoint for a collection of realms.
    Take as input, the results of the function test_existing_realms().
    """
    results = {}
    with get_requests_session() as session:
        for realm in realms_collection_infos:
            json_metadata = session.get(url=realms_collection_infos[realm], allow_redirects=True).json()
            if "registration_endpoint" in json_metadata:
                results[realm] = json_metadata["registration_endpoint"]
    return results


def test_none_signing_algorithm_support(metadata_json_url):
    """
    Find, in the OpenID configuration settings, ones for which the support of the NONE signature algorithm is enabled.
    """
    results = []
    targeted_setting_keys = ["id_token_signing_alg_values_supported", "userinfo_signing_alg_values_supported", "request_object_signing_alg_values_supported",
                             "token_endpoint_auth_signing_alg_values_supported", "introspection_endpoint_auth_signing_alg_values_supported", "revocation_endpoint_auth_signing_alg_values_supported"]
    with get_requests_session() as session:
        json_data = session.get(url=metadata_json_url, allow_redirects=True).json()
    for setting_key in targeted_setting_keys:
        for algorithm in json_data[setting_key]:
            if algorithm.lower() == "none":
                results.append(setting_key)
                break
    results.sort()
    return results


def test_hmac_signing_algorithm_support_with_public_key_export(metadata_json_url):
    """
    Find, in the OpenID configuration settings, ones for which the support of the HMAC (HS[0-9]{3,4}) signature algorithm is enabled.
    If yes, then, export all public key as PEM format in order to test exposure to "Key Confusion Attack" via the JWT tool from TICARPI.
    See https://github.com/ticarpi/jwt_tool and https://github.com/ticarpi/jwt_tool/wiki/Known-Exploits-and-Attacks#cve-2016-5431---key-confusion-attack
    """
    results = {"SettingsKeys": [], "PublicKeysExportFiles": []}
    targeted_setting_keys = ["id_token_signing_alg_values_supported", "userinfo_signing_alg_values_supported", "request_object_signing_alg_values_supported",
                             "token_endpoint_auth_signing_alg_values_supported", "introspection_endpoint_auth_signing_alg_values_supported", "revocation_endpoint_auth_signing_alg_values_supported"]
    session = get_requests_session()
    json_data = session.get(url=metadata_json_url, allow_redirects=True).json()
    # Get the list of settings supporting HMAC signature algorithm
    for setting_key in targeted_setting_keys:
        algorithms = "/".join(json_data[setting_key])
        if len(re.findall(r'HS[0-9]{3,4}', algorithms)) > 0:
            results["SettingsKeys"].append(setting_key)
    # Export public keys used to sign if settings were founds
    if(len(results["SettingsKeys"]) > 0):
        jwks_uri = json_data["jwks_uri"]
        json_data_keys = session.get(url=jwks_uri, allow_redirects=True).json()
        for key in json_data_keys["keys"]:
            public_key = None
            # See https://github.com/jpadilla/pyjwt/blob/master/jwt/algorithms.py#L69
            if key["use"] == "sig" and key["alg"].startswith("RS"):
                public_key = jwt.algorithms.RSAAlgorithm.from_jwk(key)
            elif key["use"] == "sig" and key["alg"].startswith("ES"):
                public_key = jwt.algorithms.ECAlgorithm.from_jwk(key)
            elif key["use"] == "sig" and key["alg"].startswith("PS"):
                public_key = jwt.algorithms.RSAPSSAlgorithm.from_jwk(key)
            elif key["use"] == "sig" and key["alg"].startswith("EdDSA"):
                public_key = jwt.algorithms.Ed25519Algorithm.from_jwk(key)
            if public_key is not None:
                public_key_pem = public_key.public_bytes(encoding=serialization.Encoding.PEM, format=serialization.PublicFormat.SubjectPublicKeyInfo).decode("utf-8")
                public_key_pem_file = key["kid"] + ".pem"
                with open(public_key_pem_file, mode="w", encoding="utf-8") as f:
                    f.write(public_key_pem)
                results["PublicKeysExportFiles"].append(public_key_pem_file)
    results["SettingsKeys"].sort()
    results["PublicKeysExportFiles"].sort()
    return results


def test_enabled_response_modes(base_url, responsemodes_list_source):
    """
    Identify all response modes enabled.
    """
    results = []
    # Prevent parameter collisions
    work_url = disable_existing_parameters(base_url, ["response_type", "scope", "response_mode", "code_challenge", "code_challenge_method"])
    # Add common response modes to the provided list
    resp_modes = list(set(responsemodes_list_source + COMMON_RESPONSE_MODES))
    # Use the Authorization Code flow because it is commonly enabled
    with get_requests_session() as session:
        for resp_mode in resp_modes:
            print(f"\rTesting mode: {resp_mode:<50}", end="", flush=True)
            session.cookies.clear()
            resp = session.get(url=f"{work_url}&response_type=code&scope=openid&response_mode={resp_mode}", allow_redirects=True)
            # If the response mode is not supported then an HTTP 302 is returned with the text "Invalid+parameter%3A+response_mode" in the redirection URL
            # Otherwise the login page is returned in a HTTP 200
            if get_page_type(resp) in ["LOGIN"]:
                results.append(resp_mode)
    print(f"\r{' '*50}", end="", flush=True)
    print("\r", end="", flush=True)
    results.sort()
    return results


def test_weak_pkce_code_verifier_rejection_for_plain_challenge(base_url):
    """
    Verify if weak code verifier value is rejected by the STS when PKCE with Plain Challenge Method is allowed.
    Result (return) is the weakest code challenge value accepted.
    Note that when Plain Challenge Method is allowed then "Code Verifier" == "Code Challenge".
    According to RFC7636, Code Verifier follow this pattern: [A-Za-z0-9\-\._~]{43,128}
    See https://datatracker.ietf.org/doc/html/rfc7636#section-4.1
    See https://datatracker.ietf.org/doc/html/rfc7636#section-4.2
    """
    results = "NA"
    # Prevent parameter collisions
    work_url = disable_existing_parameters(base_url, ["response_type", "scope", "code_challenge", "code_challenge_method"])
    # Use the Authorization Code with PKCE
    # Use [0]{1,129} as weak test value
    with get_requests_session() as session:
        for length in range(1, 129):
            code_challenge_test_value = "0" * length
            print(f"\rTesting value: {code_challenge_test_value:<65}", end="", flush=True)
            session.cookies.clear()
            resp = session.get(url=f"{work_url}&response_type=code&scope=openid&code_challenge={code_challenge_test_value}&code_challenge_method=plain", allow_redirects=True)
            # If the code challenge submitted is rejected then an HTTP 302 is returned with the text "Invalid+parameter%3A+code_challenge" in the redirection URL
            # Otherwise the login page is returned in a HTTP 200
            if get_page_type(resp) in ["LOGIN"]:
                results = f"'0' * {length}"
                break
    print(f"\r{' '*65}", end="", flush=True)
    print("\r", end="", flush=True)
    return results


def test_allowed_localhost_request_uri(base_url, list_local_request_uri_hit_min_delay):
    """
    Identify if a localhost request uri is allowed for the current client ID during a flow init.
    See https://openid.net/specs/openid-connect-core-1_0.html#rfc.section.6.2
    """
    # Prevent parameter collisions
    work_url = disable_existing_parameters(base_url, ["response_type", "scope", "code_challenge", "code_challenge_method", "request_uri"])
    results = []
    response_times = {}
    # Use the Authorization Code flow because it is commonly enabled
    with get_requests_session() as session:
        for port in range(1, 65536):
            for protocol in ["http", "https"]:
                for host in ["localhost", "127.0.0.1"]:
                    request_url = f"{protocol}://{host}:{port}"
                    print(f"\rTesting request url: {request_url:<50}", end="", flush=True)
                    session.cookies.clear()
                    resp = session.get(url=f"{work_url}&response_type=code&scope=openid&request_uri={request_url}", allow_redirects=True)
                    # If the request url is accepted then the login page should be presented with an HTTP 200 because we do not provide any existing session cookie.
                    # Leverage also a detection via the response time because if the hit against the specified URL is allowed but do no return a valid JWT content then a parsing error
                    # is raised by the server and an generic error page is returned (no disclosure of the kind of error meet).
                    if get_page_type(resp) == "LOGIN":
                        results.append(f"{request_url} (identified via the http response type)")
                    elif get_page_type(resp) == "SERVER_SIDE_ERROR":
                        response_times[request_url] = resp.elapsed.microseconds
    print(f"\r{' '*50}", end="", flush=True)
    print("\r", end="", flush=True)
    # Identify potential hidden hit the adjustement response time
    if len(response_times) > 0:
        response_times_collection = list(response_times.values())
        print(colored("[i]", info_color, attrs=["bold"]) + f" Average response time was {int(statistics.mean(response_times_collection)):<6} microseconds.")
        print(colored("[i]", info_color, attrs=["bold"]) + f" Median  response time was {int(statistics.median(response_times_collection)):<6} microseconds.")
        print(colored("[i]", info_color, attrs=["bold"]) + f" Max     response time was {max(response_times_collection):<6} microseconds.")
        # Take all requests for which the response time is superior to the limit defined to identify effective hits by the STS against forged URL
        for response_time in response_times:
            if response_times[response_time] > list_local_request_uri_hit_min_delay:
                results.append(f"{response_time} (identified via the http response time of {response_times[response_time]} microseconds - False positive possible)")
    results.sort()
    return results


if __name__ == "__main__":
    colorama.init()
    title_color = "yellow"
    info_color = "cyan"
    parser = argparse.ArgumentParser()
    required_params = parser.add_argument_group("required arguments")
    required_params.add_argument("--client-id", action="store", dest="client_id", help="Identifier of the target Client.", required=True)
    required_params.add_argument("--valid-redirect-uri", action="store", dest="valid_redirect_uri", help="Valid redirection uri for the target Client.", required=True)
    required_params.add_argument("--sts-endpoint", action="store", dest="sts_base_url", help="OAUTH/OIDC endpoint to use (ex: http://localhost:8080/auth/realms/demo/protocol/openid-connect/auth).", required=True)
    parser.add_argument("--proxy", action="store", dest="http_proxy", default=None, help="HTTP proxy to use for all HTTP call to differents services (ex: http://88.198.50.103:9080). Default to None", required=False)
    parser.add_argument("--words-file", action="store", dest="words_dictionary", default="/tools/sec-lists/Discovery/Web-Content/raft-small-words.txt", help="Path to a text file containing words used for all enumeration operations. Default to the file 'raft-small-words.txt' from the local SecLists GitHub repo clone.", required=False)
    parser.add_argument("--list-local-redirect", action="store_true", dest="list_local_redirect", default=False, help="List allowed localhost redirection on the STS for the specified Client ID. Default to False", required=False)
    parser.add_argument("--list-local-request-uri", action="store_true", dest="list_local_request_uri", default=False, help="List allowed localhost request uri on the STS for the specified Client ID during flow init. Default to False", required=False)
    parser.add_argument("--list-local-request-uri-hit-min-delay", action="store", dest="list_local_request_uri_hit_min_delay", default=10000, help="For the allowed localhost request uri test, minimum delay in microseconds indicating a hit by the STS against a local forged url. Default to 10000", required=False)
    parser.add_argument("--tls-client-cert-pem-file", action="store", dest="tls_client_cert_pem_file", default=None, help="TLS client certificate file to use for all HTTP requests (PEM format). Default to None", required=False)
    parser.add_argument("--tls-client-cert-key-pem-file", action="store", dest="tls_client_cert_key_pem_file", default=None, help="TLS client certificate private key file to use for all HTTP requests (PEM format). Default to None", required=False)
    args = parser.parse_args()
    words_file = args.words_dictionary
    if args.http_proxy is not None:
        PROXIES["http"] = args.http_proxy
        PROXIES["https"] = args.http_proxy
    else:
        PROXIES.clear()
    if args.tls_client_cert_pem_file is not None and args.tls_client_cert_key_pem_file is not None:
        TLS_CLIENT_CERT = (args.tls_client_cert_pem_file, args.tls_client_cert_key_pem_file)
    else:
        TLS_CLIENT_CERT = None
    print(colored("[i]", info_color, attrs=["bold"]) + " STS refer to the target 'OAuth Authorization Server' or 'OpenID Provider' instance.")
    print(colored(f"[+] Compose the base url based on parameters provided:", title_color, attrs=["bold"]))
    work_url = args.sts_base_url.split("?")[0]
    client_id = args.client_id
    redirect_uri = args.valid_redirect_uri
    state = str(uuid.uuid4())
    list_local_request_uri_hit_min_delay = int(args.list_local_request_uri_hit_min_delay)
    base_url = f"{work_url}?client_id={client_id}&redirect_uri={redirect_uri}&state={state}"
    print(base_url)
    print(colored(f"[+] Identify the software operating the STS...", title_color, attrs=["bold"]))
    results = get_system_software(base_url)
    print(results)
    print(colored(f"[+] Load the list of words from file '{words_file}'...", title_color, attrs=["bold"]))
    with open(words_file, "r") as f:
        words = f.read().splitlines()
    words.append(client_id)
    words.append(client_id.lower())
    words.append(client_id.upper())
    words.append(client_id.capitalize())
    print(f"{len(words)} words loaded in memory.")
    print(colored(f"[+] List enabled flows on the STS for the specified Client ID...", title_color, attrs=["bold"]))
    flows_enabled_status = test_enabled_flows(base_url)
    render_results(flows_enabled_status, column_headers=["Flow", "Enabled"])
    print(colored(f"[+] Enumerate allowed Scopes on the STS for the specified Client ID...", title_color, attrs=["bold"]))
    results = test_allowed_scopes(base_url, words)
    render_results(results)
    print(colored(f"[+] Enumerate defined Clients on the STS...", title_color, attrs=["bold"]))
    client_id_list = test_existing_clients(base_url, words)
    render_results(client_id_list)
    print(colored(f"[+] Enumerate protected apps by the STS...", title_color, attrs=["bold"]))
    results = test_map_client_to_protected_app(base_url, client_id_list)
    render_results(results, column_headers=["Client ID", "App URL"])
    print(colored(f"[+] Enumerate defined Realms on the STS...", title_color, attrs=["bold"]))
    realms = test_existing_realms(base_url, words)
    render_results(realms, column_headers=["Realm ID", "Metadata endpoint URL"])
    print(colored(f"[+] Enumerate client self-registration endpoint for defined Realms on the STS...", title_color, attrs=["bold"]))
    results = test_realms_client_self_registration_endpoint(realms)
    render_results(results, column_headers=["Realm ID", "Client self-registration endpoint URL"])
    print(colored(f"[+] Enumerate defined Realms on the STS for which the NONE signature algorithm is supported...", title_color, attrs=["bold"]))
    results = {}
    for realm_name, realm_metadata_endpoint in realms.items():
        settings = test_none_signing_algorithm_support(realm_metadata_endpoint)
        if len(settings) > 0:
            results[realm_name] = settings
    render_results(results, column_headers=["Realm ID", "Setting keys"])
    print(colored(f"[+] Enumerate defined Realms on the STS for which the HMAC signature algorithm is supported and export public keys to PEM files [KID].pem...", title_color, attrs=["bold"]))
    print(colored("[i]", info_color, attrs=["bold"]) + " Key-Confusion attack via the TICARPI JWT tool: python3 jwt_tool.py 'SOURCE_JWT_TOKEN' -X k -pk [KID].pem")
    print("    Use the key file with the KID (Key ID) with the value of the header 'kid' from 'SOURCE_JWT_TOKEN'.")
    results = {}
    for realm_name, realm_metadata_endpoint in realms.items():
        settings = test_hmac_signing_algorithm_support_with_public_key_export(realm_metadata_endpoint)
        if len(settings["SettingsKeys"]) > 0:
            print(colored(f"Realm '{realm_name}'", info_color, attrs=["bold"]))
            print(f"  Setting keys: ", end="", flush=True)
            render_results(settings["SettingsKeys"])
            print(f"  Key files: ", end="", flush=True)
            render_results(settings["PublicKeysExportFiles"])
    print(colored(f"[+] Enumerate enabled Response Modes on the STS for the specified Client ID...", title_color, attrs=["bold"]))
    results = test_enabled_response_modes(base_url, words)
    render_results(results)
    if flows_enabled_status["AUTHORIZATION_CODE_WITH_PKCE_WITH_PLAIN_CHALLENGE"]:
        print(colored(f"[+] Identify the weakest Code Challenge value accepted by the STS for the specified Client ID in a context of Authorization Code with PKCE using PLAIN code challenge method...", title_color, attrs=["bold"]))
        results = test_weak_pkce_code_verifier_rejection_for_plain_challenge(base_url)
        render_results(results)
    if args.list_local_redirect:
        print(colored(f"[+] List allowed localhost redirection on the STS for the specified Client ID...", title_color, attrs=["bold"]))
        results = test_allowed_localhost_redirection(base_url)
        render_results(results)
    if args.list_local_request_uri:
        print(colored(f"[+] List allowed localhost request uri on the STS for the specified Client ID during a flow init, min delay set to {list_local_request_uri_hit_min_delay} microseconds...", title_color, attrs=["bold"]))
        results = test_allowed_localhost_request_uri(base_url, list_local_request_uri_hit_min_delay)
        render_results(results)
